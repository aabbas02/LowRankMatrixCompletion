clc
close all
clear all
dir = pwd;
% For linux, replace '\' with '/'
cd ..
%addpath(genpath('.\functions'));
addpath(genpath('.\functionsMtrxSnsng'));
addpath(genpath('.\utils'));
cd(dir)    
%---------------------------------
r = 2;
n = 600;
q = 1000;
p = 0.1;
same = 0;
numBlocks = 25;   %effectively, m_new = numBlocks
r_ = ones(1,numBlocks)*(n/numBlocks);
T = 200;
MC = 1;
% generate rank-r X*
Ustr = orth(randn(n,r));
Bstr = randn(r,q);
X  = Ustr*Bstr;
% generate q matrices A_k of size m x n, m << n
%SDVals_UnPerm = zeros(MC,T+1);
%SDVals_sLcl = zeros(MC,T+1);
%SDVals_Perm = zeros(MC,T+1);
%------------------------
rowIdxPerm = cell(q,1);
XcolPerm = cell(q, 1); 
XzerosPerm = zeros(n,q);
XzerosCllps = zeros(n,q);
%-----------------------
for mc = 1 : MC
    %if same
    %    pi_map = get_permutation_r(n,r_);
    %end
    [Xzeros, rowIdx, colIdx, Xcol, Xrow] = processMatrix(X, n, q, p);
    for k = 1 : q
        l_k = length(rowIdx{k});
        r_ = floor(l_k/numBlocks)*ones(numBlocks,1);
        if mod(l_k,numBlocks) > 0
            r_(end+1) = l_k - floor(l_k/numBlocks)*numBlocks;
        end
        if ~same
            pi_map = get_permutation_r(l_k,r_);
        end
        % get rowIdxPerm
        % get XcolPerm
        % make XzerosPerm
        % make XzerosCllps
        rowIdxPerm{k} = rowIdx{k}(pi_map);
        %XcolPerm{k} = Xcol{k}(rowIdxPerm{k});
        XcolPerm{k} = Xzeros(rowIdxPerm{k},k);
        XzerosPerm(rowIdxPerm{k},k) = Xcol{k};
        for s = 1 : length(r_)
            start = sum(r_(1:s)) - r_(s) + 1;
            stop = start + r_(s) - 1;
            % This is wrong. 
            % The start and stop are with respect to column vector of 
            % length equal to number of observed entries.
            % The column of XzerosCllps has n entries, not length equal to
            % number of observed entries.
            %k,s
            XzerosCllps(rowIdxPerm{k}(start),k) = sum(XcolPerm{k}(start:stop));
        end
        %{
        %ykPerm_{k} = yk_{k}(pi_map);
        %AkCllps_{k} = zeros(length(r_),n);
        %ykCllps_{k} = zeros(length(r_),1);
        %    for i = 1 : length(r_)
        %        start = sum(r_(1:i)) - r_(i) + 1;
        %        stop  = sum(r_(1:i));
        %        AkCllps_{k}(i,:) = sum(Ak_{k}(start:stop,:));
        %        ykCllps_{k}(i) = sum(ykPerm_{k}(start:stop,:));
        %    end
        %MCllps(:, k) = AkCllps_{k}'*ykCllps_{k};
        %MPerm(:, k) = Ak_{k}'*ykPerm_{k};
        %}
    end
    [U0,~,~,] = svd(Xzeros,"econ");
    U0 = U0(:,1:r);
    SDU0 = norm(Ustr - U0*(U0'*Ustr))
    %-----------------------------------
    norm(Xzeros - XzerosCllps,'fro')
    [U0Cllps,~,~] = svd(XzerosCllps,"econ");
    U0Cllps = U0Cllps(:,1:r);
    SDU0Cllps = norm(Ustr - U0Cllps*(U0Cllps'*Ustr))
    %---------------------------------------
    [U0Perm,~,~] = svd(XzerosPerm,"econ");
    U0Perm = U0Perm(:,1:r);
    SDU0Perm = norm(Ustr - U0Perm*(U0Perm'*Ustr))    
    mc
end
function [Xzeros, rowIdx, colIdx, Xcol, Xrow] = processMatrix(X, n, q, p)
    % Randomly select indices based on probability p
    idx = randperm(n * q);
    idx = idx(1:round(p * n * q));
    idxC = setdiff(1:n * q, idx);

    % Convert linear indices to subscripts
    [row, col] = ind2sub([n, q], idx);

    % Instantiate Y = X_Omega (Observed entries)
    Xzeros = zeros(n, q);
    Xzeros(idx) = X(idx);

    % Initialize cell arrays
    rowIdx = cell(q, 1); 
    colIdx = cell(n, 1);
    Xcol = cell(q, 1); 
    Xrow = cell(n, 1);

    % Parallel processing
    parfor j = 1:q
        rowIdx{j} = row(col == j);
        Xcol{j} = X(rowIdx{j}, j);
        if j <= n
            colIdx{j} = col(row == j);
            Xrow{j} = X(j, colIdx{j})';
        end
    end
end

%---
%plotRslts(SDVals_sLcl, SDVals_Perm, SDVals_UnPerm,n,q,r,m,numBlocks,MC,same);
function plotRsltsLRMCInit(numBlocks_, SDVals_,n,q,r,m,MC,same)
    figure;
    %SDVals_
    %SDVals_UnPerm = sum(SDVals_UnPerm,1)/MC;
    %SDVals_sLcl = sum(SDVals_sLcl,1)/MC;
    semilogy(numBlocks_,SDVals_, ...
        'DisplayName', 'SDVals-Spectral Init LRMC', 'LineWidth', 1.45, 'Marker', 'o', 'MarkerSize', 7);
    hold on;
    %semilogy(SDVals_Perm, ...
    %    'DisplayName', 'SDVals (Naive)', 'LineWidth', 1.45, 'Marker', 'square', 'MarkerSize', 7);
    %
    %semilogy(SDVals_UnPerm, ...
    %    'DisplayName', 'SDVals (Unpermuted)', 'LineWidth', 1.45, 'Marker', 'x', 'MarkerSize', 7);
    %grid on
    
    
    title("n = " + n + ", q = " + q +...
          ", r = " + r + ", m = " + m + ", num Blocks = " + numBlocks +  ", MC = " + MC + ", same = " + same, ...
           'Interpreter', 'Latex', 'FontSize',14)
    
    legend('Interpreter', 'Latex', 'Fontsize', 9);
    ylabel("$SD(U,U^*)$","FontSize",14,'Interpreter','Latex')
    xlabel('Iterations (t)', 'FontSize',14, 'Interpreter','Latex')
    stringTitle = ['MtrxSnsngPerm_MC_', num2str(MC), ...
                   '_n_', num2str(n), '_q_', num2str(q), '_r_', num2str(r), '_m_', num2str(m), '_numBlocks_',num2str(numBlocks), '_same_',num2str(same)];
    
    savefig([stringTitle, '.fig']);
end