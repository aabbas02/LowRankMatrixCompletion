function [SDVals,times] = altGDMin_MtrxSensingPerm(Ak_, ykPerm_,AkCllps_,ykCllps_,Uinit,r,T,Ustr,r_,updtP,same,altMin,T_LS,exact)
	% This function should implement altGDMin with both permuted and non-permuted measurements
	% The above functionality is achieved by setting the arguments correspondingly
	% AltGDMin wout Perm: updtP = 0, Uinit = U0, Ak_ = Ak, ykPerm_ = yk, AkCllps_ = Ak, ykCllps_ = yk
	% AltGDMin with Perm: updtP = 1, Uinit = U0Cllps, Ak_ = Ak, ykPerm_ = ykPerm, AkCllps_ = AkCllps_, ykCllps_ = ykCllps_
	%---
    % Algorithm
    % Init gives U^(0), B^(0), where B^(0) is by collapsed estimate
    % Steps: min P, min U, min B
    % if t == 0, update bk by collapsed estimate, else update by full
    m = size(Ak_{1}, 1);
    n = size(Ak_{1}, 2);
    SDVals = zeros(T+1,1);
    times = zeros(T+1,1);
    U = Uinit;
    SDVals(1) = norm((eye(n) - U*U')*Ustr ,'fro');
    q = length(ykPerm_);
    B = zeros(r,q);
    gradU = zeros(n,r);
    
    %if updtP && same
        yHat = zeros(m,q);
        yPerm = zeros(m,q);
        for k =  1 : q
            yPerm(:,k) = ykPerm_{k};
        end
    %end
    if altMin 
        T_in = T_LS;
        if exact
            y_all = vertcat(ykPerm_);
            M_sns = zeros(q*m,n*r);
        end
    else
        T_in = 1;
    end    
    for i = 1 : T
        tStart = tic;
        for k = 1 : q
            % Least-squares B_k update
            if i == 1 % collapsed least-squares
                B(:,k) = (AkCllps_{k}*U)\ykCllps_{k};
            else % full measurements least-squares
                B(:,k) = (Ak_{k}*U)\ykPerm_{k};
            end
            if updtP 
                yHatk = Ak_{k}*U*B(:,k);
                yHat(:,k) = yHatk;
                if same == 0
                    for s = 1 : length(r_)
                        start = sum(r_(1:s)) - r_(s) + 1;
                        stop = sum(r_(1:s));
                        %C = yPerm(start:stop,k)*yHat(start:stop,k)';                    
                        %M = matchpairs(-C,1e10); % M is a matrix with 2 columns and m rows, 
                                                 % The second column has ascending
                                                 % indices in order 1, ..., m
                                                 % The first column has the
                                                 % corresponding/matching row indices
                                                 % 5,1 means P(5,1) = 1, i.e., 
                                                 % row 5 matched to 1
                        %idx  = M(:,1);
                        %idx = start - 1  + idx;
                        %Ak_{k}(idx,:) = Ak_{k}(start:stop,:);  
                        [~,idx1] = sort(yHatk(start:stop));
                        [~,idx2] = sort(ykPerm_{k}(start:stop));
                        idx1 = start - 1 + idx1;
                        idx2 = start - 1 + idx2;
                        Ak_{k}(idx2,:) = Ak_{k}(idx1,:);
                    end                    
                end
            end
        end
        if updtP && same == 1
            for s =  1 : length(r_)
                start = sum(r_(1:s)) - r_(s) + 1;
                stop = sum(r_(1:s));
                C = yPerm(start:stop,:)*yHat(start:stop,:)';
                M = matchpairs(-C,1e100); % M is a matrix with 2 columns and m rows, 
                                         % The second column has ascending
                                         % indices in order 1, ..., m
                                         % The first column has the
                                         % corresponding/matching row indices
                                         % 5,1 means P(5,1) = 1, i.e., 
                                         % row 5 matched to 1
                idx  = M(:,1);
                idx = start - 1  + idx;
                for k = 1 : q
                   
                    Ak_{k}(idx,:) = Ak_{k}(start:stop,:);       
                    if exact
                        M_sns((k-1)*m+1 : k*m,:) = B(:,l)
                    end
                end
            end
        end
        % U update
        if altMin && exact % U update by least - squares
            %A_all = vertcat(Ak_);
            %A_all = cat(1,Ak_{:});
            %M = kron(B',A_all);
            Uvec = M/y_all; 
            U = reshape(Uvec,[n,r]);
        else
            X = U*B;
            if i == 1
                if altMin
                    L = norm(Ak_{k},2)^2*norm(B,"fro")^2;
                    eta = 1/L; 
                else
                    maxSigma = norm(X);
                    eta = 1e0/(m*maxSigma^2);
                end
            end
            gradU = 0*gradU;
            t_in = 0;
            while t_in == 0 || t_in <= T_in && norm(gradU) >= 1e-10 % do a minimum of 1 iteration and a maximum of T_in iterations
            %for t_in = 1:T_in
                gradU = 0*gradU;
                for k = 1 : q
                    gradU = gradU + Ak_{k}'*(Ak_{k}*X(:,k)-ykPerm_{k})*B(:,k)';
                end
                U = U - eta*gradU;
                X = U*B;
            %end
                t_in = t_in + 1;
            end
            tStrtQR = tic;
            [Uproj,~,~] = qr(U,'econ');
            tQR = toc(tStrtQR);
            if altMin
                times(i+1) = times(i) + toc(tStart)  - tQR;
            else
                times(i+1) = times(i) + toc(tStart);
            end
        end
        SDVals(i + 1) = norm( Ustr - Uproj*(Uproj'*Ustr) ,'fro' );
        if altMin == 0 %altMin = 0 means altGDMin
            U = Uproj; 
        end
    end
end
