% Parameters
tic
clear all
close all
clc
r = 5;  % rank
Telem = 1000;  % number of iterations
Tgm = 1000;
mu = 2;  % parameter for projection operator
attck = 0;
L = 20;   % number of nodes
L_byz = 8;
C1 = 1e0;
MC = 1;
error = zeros(4,Telem,MC);
errorX = zeros(4,Telem,MC);
for mc = 1 : MC
    % Generate Y and S
    %[Y,Ycol,rowIdx,Ycol_,rowsJ] = genY_and_IdxNew(Xstar, p, L);
    %[~,sigma,~] = svds(Xstar,r);
    %kappa_tilde = sigma(1,1)/sigma(r,r);
    
    [Ustar,Y,p] = getMovieLens(r);
    real = 1; idxFlag = 0; 
    [Y, rowIdx, ~, Ycol, ~,idx, Ycol_,rowsJ] = processMatrix(Y,p,real,idxFlag,L);
    n = size(Y,1); q = size(Y,2);    
    [U0_init,S1,~] = svds(Y/p,r);
    kappa_tilde = S1(1,1)/S1(r,r);    
    U = U0_init(:,1:r);
    eta = 1/(S1(1,1)^2*p);
    %--------------------------------------------------------
    % GD step element wise median
    %----------------------------------------------------------
    U_t_prev = U;
    nrmsPrev = sqrt(sum(U_t_prev.^2,2));
    for t = 1 : Telem
        [stored_delta] = nodeLoopReal(U_t_prev,q,n,r,rowIdx,Ycol,L,rowsJ,Ycol_);
        byz_rev = byzantine_rev(L_byz,stored_delta,C1,attck);
        for j = 1 : L_byz
            idx_ = randi([1,L]);
            stored_delta(:,:,idx_) = byz_rev(:,:,j);
        end
        I_t = [];
        for i = 1 : L
           U_temp = U_t_prev - eta * stored_delta(:,:,i);
           nrmsTemp = sqrt(sum(U_temp.^2,2)); %norm(U_temp')
           accept_update = all(nrmsTemp <= (1 - 0.4 / (kappa_tilde^2)) *nrmsPrev + 1.4 * mu * sqrt(r / n));
           if accept_update
              I_t = [I_t, i];  % Add index i to the set I_t
           else
              fprintf('Idx %d. Node %d rejected based on norm condition.\n', idx, i);
           end   
        end
        accepted_deltas = stored_delta(:,:,I_t);
        Grad_U = coordinate_wise_median(accepted_deltas);
        U_cap = U_t_prev - eta * Grad_U;
        [Q1,~] = qr(U_cap);
        U_t_prev=Q1(:,(1:r));
        nrmsPrev = sqrt(sum(U_t_prev.^2,2));
        error(2,t,mc) = getErr(U_t_prev,r,q,L,rowsJ,Ycol_,Y,idx);        

        if mod (t,100) == 0
            fprintf('Elmnt Median. n = %d, q = %d, r = %d, p = %f, L = %d, L_byz = %d, C1 = %d, Attack = %d. Iter. %d, Rel. Error: %f\n', n,q,r,p,L,L_byz,C1, attck, t, error(2,t,mc));
        end
    end
    %---------------------------------
    % GD step GM with check and attacks
    %---------------------------------
    %{
    U_t_prev = U;
    nrmsPrev = sqrt(sum(U_t_prev.^2,2));
    for t = 1 : 1 * Tgm
        [stored_delta] = nodeLoopReal(U_t_prev,q,n,r,rowIdx,Ycol,L,rowsJ,Ycol_);        
        byz_rev=byzantine_rev(L_byz,stored_delta,C1,attck);
        for j = 1 : L_byz
            idx_ = randi([1,L]);
            %idx = 1;
            stored_delta(:,:,idx_) = byz_rev(:,:,j);
        end
        I_t = [];
        for i = 1 : L
           U_temp = U_t_prev - eta * stored_delta(:,:,i);
           nrmsTemp = sqrt(sum(U_temp.^2,2)); %norm(U_temp')
           accept_update = all(nrmsTemp <= (1 - 0.4 / (kappa_tilde^2)) *nrmsPrev + 0.4 * mu * sqrt(r / n));
           % If all conditions are met, accept the update for this node
           if accept_update
              I_t = [I_t, i];  % Add index i to the set I_t
           else
              fprintf('Idx %d. Node %d rejected based on norm condition.\n', idx, i);
           end   
        end
        accepted_deltas = stored_delta(:,:,I_t);
        Grad_U = do_gm_vec(accepted_deltas);
        U_cap=U_t_prev - eta * Grad_U;
        [Q1,~] = qr(U_cap);
        U_t_prev=Q1(:,(1:r));
        nrmsPrev = sqrt(sum(U_t_prev.^2,2));
        error(3,t,mc) = getErr(U_t_prev,r,q,L,rowsJ,Ycol_,Y,idx);        
        %error(3,t,mc) = subspace(Ustar,U_t_prev,n)/sqrt(r);
        if mod (t,100) == 0
             fprintf('GM.  n = %d, q = %d, r = %d, p = %f, L = %d, L_byz = %d, C1 = %d. Iteration %d, Rel. Error: %f\n', n,q,r,p, L,L_byz, C1, t, error(3,t,mc));
        end
    end
    %}
    %----------------------------------
    %GD step Krum with check and attack
    %----------------------------------
    U_t_prev = U;
    nrmsPrev = sqrt(sum(U_t_prev.^2,2));
    for t = 1 : Tgm
        [stored_delta] = nodeLoopReal(U_t_prev,q,n,r,rowIdx,Ycol,L,rowsJ,Ycol_);        
        byz_rev=byzantine_rev(L_byz,stored_delta,C1,attck);
        for j = 1 : L_byz
            idx_ = randi([1,L]);
            stored_delta(:,:,idx_) = byz_rev(:,:,j);
        end
        I_t = [];
        for i = 1 : L
            U_temp = U_t_prev - eta * stored_delta(:,:,i);
            nrmsTemp = sqrt(sum(U_temp.^2,2)); %norm(U_temp')
            accept_update = all(nrmsTemp < (1 - 0.4 / (kappa_tilde^2)) *nrmsPrev + 1.4 * mu * sqrt(r / n));
            % If all conditions are met, accept the update for this node
            if accept_update
                I_t = [I_t, i];  % Add index i to the set I_t
            else
                fprintf('Idx %d. Node %d rejected based on norm condition.\n', idx, i);
            end
        end
         accepted_deltas = stored_delta(:,:,I_t);
         Grad_U = krum(accepted_deltas, L_byz);
         U_cap=U_t_prev - eta * Grad_U;
         [Q1,~] = qr(U_cap);
         U_t_prev=Q1(:,(1:r));
         nrmsPrev = sqrt(sum(U_t_prev.^2,2));
         error(4,t,mc) = getErr(U_t_prev,r,q,L,rowsJ,Ycol_,Y,idx);          
         if mod(t,100) == 0
             fprintf('Krum. Iteration %d, Rel Error: %f\n', t, error(4,t,mc));
         end
    end
    mc
end
error_mean_MC = mean(error,3);
plotErrorMean(error_mean_MC, n, q, r, p, L, L_byz, MC, C1, attck,real)
toc
function [err] = getErr(U,r,q,numWrkrs,rowsJ,Xcol_,Y,idx)
    B = zeros(r,q);
    for j = 1 : numWrkrs
        tmp = zeros(r,q/numWrkrs);
        rowIdxj = rowsJ(j,:); 
        XcolJ = Xcol_(j,:);
        for k = 1 : q/numWrkrs
           rowIdx_jk = rowIdxj{k};
           tmp(:,k) = U(rowIdx_jk,:)\XcolJ{k};
        end
        offset = (j-1)*q/numWrkrs;        
        B(:,offset+1:(j*q)/numWrkrs) = tmp;
    end
    X = U*B;
    err = norm(X(idx) - Y(idx))/norm(Y(idx));
end
%-------------
function [Ustr,X,p] = getMovieLens(r)
    %A = readmatrix("ratings100K.xlsx");
    %--------------------
    %load("ratings1M.mat");
    %A = ratings1M;
    %--------------------
    %load("ratings10M.mat")
    %A = ratings10M;
    n = max(A(:,1));
    q = max(A(:,2));
    X = zeros(n,q);
    num = 0;
    for k = 1 : size(A,1)
        i = A(k,1);
        j = A(k,2);
        X(i,j) = A(k,3);
        num = num + 1;
    end
    p = num/(n*q);
    X = X';
    [Ustr,~,~] = svds(X,r);
    Ustr = Ustr(:,1:r);
end
%-------------
function [Xzeros, rowIdx, colIdx, Xcol, Xrow,idx, Xcol_,rowsJ] = processMatrix(X, p,real,idxFlag,L)
    n = size(X,1); q = size(X,2);
    if real
        idx = find(X > 0);
    elseif idxFlag      % Randomly select indices based on probability p
        idx = randperm(n * q);
        idx = idx(1:round(p * n * q));
    end
    % Convert linear indices to subscripts
    [row, col] = ind2sub([n, q], idx);
 
    % Instantiate Y = X_Omega (Observed entries)clclc
    Xzeros = zeros(n, q);
    Xzeros(idx) = X(idx);
    q = L*floor(q/L);
    Xzeros = Xzeros(:, 1:q);
    idx = find(Xzeros > 0);
    % Initialize cell arrays
    rowIdx = cell(q, 1); 
    colIdx = cell(n, 1);
    Xcol = cell(q, 1); 
    Xrow = cell(n, 1);
    % Parallel processing
    for j = 1 : q
        rowIdx{j} = row(col == j);
        Xcol{j} = X(rowIdx{j}, j);
    end
    for j = 1 : n
        colIdx{j} = col(row == j);
        Xrow{j} = X(j, colIdx{j})';        
    end
    Xcol_ = cell(L,q/L);  
    rowsJ = reshape(rowIdx,[q/L,L]);
    rowsJ = rowsJ';    
    for j = 1 : L
        offset = (j-1)*q/L;
        for k = 1 : q/L
            Xcol_{j,k} = Xcol{offset+k};
        end
    end    
end